#include "mlir/Transforms/Passes.h"
#include "triton/Dialect/TritonGPU/IR/Dialect.h"
#include "triton/Dialect/TritonGPU/Transforms/Passes.h"
#include "triton/Dialect/TritonGPU/Transforms/Utility.h"

#include <memory>

using namespace mlir;
using namespace triton;
using namespace triton::gpu;

// TODO(jlebar): These autogenerated headers (and the passes they declare)
// should be included within a namespace, but we have to do it consistently.
#define GEN_PASS_CLASSES
#include "triton/Dialect/TritonGPU/Transforms/Passes.h.inc"

class FoldTensorSelectIntoIfPass
    : public TritonGPUFoldTensorSelectIntoIfBase<FoldTensorSelectIntoIfPass> {
public:
  explicit FoldTensorSelectIntoIfPass() = default;

  void runOnOperation() override {
    MLIRContext *context = &getContext();
    ModuleOp m = getOperation();

    // Go over the arith.select ops, look if there is an if
    // with the same condition, and if so, fold the select into the if.
    DenseMap<arith::SelectOp, scf::IfOp> selectToIf;
    m.walk([&](arith::SelectOp selectOp) {
      // Look if there is an if in the same block, with the same condition.
      auto *parentBlock = selectOp->getBlock();
      Value condition = selectOp.getOperand(0);
      // Get condition's users
      for (auto user : condition.getUsers()) {
        if (auto ifOp = dyn_cast<scf::IfOp>(user)) {
          if (ifOp->getBlock() == parentBlock) {
            selectToIf[selectOp] = ifOp;
          }
        }
      }
    });

    for (auto [selectOp, ifOp] : selectToIf) {
      // Add new return value to the if (and create else block if necessary),
      // then yield the select value in the then block and the else block.
      OpBuilder builder(ifOp);
      auto loc = ifOp.getLoc();
      auto thenValue = selectOp.getTrueValue();
      auto elseValue = selectOp.getFalseValue();
      // Create an scf::IfOp with extra return value.
      SmallVector<Type> newResultTypes = {ifOp.getResultTypes().begin(),
                                          ifOp.getResultTypes().end()};
      newResultTypes.push_back(selectOp.getResult().getType());
      auto newIfOp = builder.create<scf::IfOp>(
          loc, newResultTypes, ifOp.getCondition(), /*hasElse*/ true);
      // Move the existing blocks to the new if.
      newIfOp.getThenRegion().takeBody(ifOp.getThenRegion());

      if (ifOp.elseBlock()) {
        newIfOp.getElseRegion().takeBody(ifOp.getElseRegion());
      } else {
        // Create an empty yield
        auto yieldOp = newIfOp.getElseBodyBuilder().create<scf::YieldOp>(loc);
      }

      // Update yields
      {
        auto thenYield = newIfOp.thenYield();
        SmallVector<Value> operands(thenYield->getOperands());
        operands.append({thenValue});

        OpBuilder builder(thenYield);
        builder.create<scf::YieldOp>(thenYield->getLoc(), operands);
        thenYield->erase();
      }
      {
        auto elseYield = newIfOp.elseYield();
        SmallVector<Value> operands(elseYield->getOperands());
        operands.append({elseValue});

        OpBuilder builder(elseYield);
        builder.create<scf::YieldOp>(elseYield->getLoc(), operands);
        elseYield->erase();
      }

      // Replace old if with the new one.
      for (auto result : ifOp.getResults()) {
        result.replaceAllUsesWith(newIfOp->getResult(result.getResultNumber()));
      }
      // Replace the select with the new return value.
      selectOp.replaceAllUsesWith(
          newIfOp->getResult(newIfOp->getNumResults() - 1));
      selectOp.erase();
      ifOp.erase();
    }
  }
};

std::unique_ptr<Pass> mlir::triton::gpu::createFoldTensorSelectIntoIfPass() {
  return std::make_unique<FoldTensorSelectIntoIfPass>();
}
